use super::{Array, ArrayBuilder, ArrayValidExt};
use crate::types::NativeType;
use bitvec::prelude::{BitSlice, BitVec, Lsb0};
use serde::{Deserialize, Serialize};
use std::iter::FromIterator;

/// A collection of primitive types, such as `i32`, `f32`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PrimitiveArray<T: NativeType> {
    valid: BitVec,
    data: Vec<T>,
}

// Enable `collect()` an array from iterator of `Option<T>`.
impl<T: NativeType> FromIterator<Option<T>> for PrimitiveArray<T> {
    fn from_iter<I: IntoIterator<Item = Option<T>>>(iter: I) -> Self {
        let iter = iter.into_iter();
        let mut builder = <Self as Array>::Builder::new(iter.size_hint().0);
        for e in iter {
            builder.push(e.as_ref());
        }
        builder.finish()
    }
}

// Enable `collect()` an array from iterator of `T`.
impl<T: NativeType> FromIterator<T> for PrimitiveArray<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        iter.into_iter().map(Some).collect()
    }
}

impl<T: NativeType> Array for PrimitiveArray<T> {
    type Item = T;
    type Builder = PrimitiveArrayBuilder<T>;

    fn get(&self, idx: usize) -> Option<&T> {
        self.valid[idx].then(|| &self.data[idx])
    }

    fn len(&self) -> usize {
        self.valid.len()
    }
}

impl<T: NativeType> ArrayValidExt for PrimitiveArray<T> {
    fn get_valid_bitmap(&self) -> &BitVec {
        &self.valid
    }
}

/// A builder that constructs a [`PrimitiveArray`] from `Option<T>`.
pub struct PrimitiveArrayBuilder<T: NativeType> {
    valid: BitVec,
    data: Vec<T>,
}

impl<T: NativeType> ArrayBuilder for PrimitiveArrayBuilder<T> {
    type Array = PrimitiveArray<T>;

    fn new(capacity: usize) -> Self {
        Self {
            valid: BitVec::with_capacity(capacity),
            data: Vec::with_capacity(capacity),
        }
    }

    fn push(&mut self, value: Option<&T>) {
        self.valid.push(value.is_some());
        self.data.push(value.cloned().unwrap_or_default());
    }

    fn append(&mut self, other: &PrimitiveArray<T>) {
        self.valid.extend_from_bitslice(&other.valid);
        self.data.extend_from_slice(&other.data);
    }

    fn finish(self) -> PrimitiveArray<T> {
        PrimitiveArray {
            valid: self.valid,
            data: self.data,
        }
    }
}

impl<T: NativeType> PrimitiveArray<T> {
    /// Returns a batch iterator for SIMD.
    ///
    /// Each item contains at most `N` elements.
    pub fn batch_iter<const N: usize>(&self) -> BatchIter<'_, T, N> {
        assert!(N <= std::mem::size_of::<usize>() * 8);
        BatchIter {
            array: self,
            idx: 0,
        }
    }
}

/// An iterator over a batch elements of the array at a time.
pub struct BatchIter<'a, T: NativeType, const N: usize> {
    array: &'a PrimitiveArray<T>,
    idx: usize,
}

/// A batch elements generated by `BatchIter`.
#[derive(Debug, PartialEq, Eq)]
pub struct BatchItem<T: NativeType, const N: usize> {
    /// The valid (non-NULL) bitmap.
    pub valid: usize,
    /// The elements.
    pub data: [T; N],
    /// The length of the batch.
    pub len: usize,
}

impl<T: NativeType, const N: usize> Iterator for BatchIter<'_, T, N> {
    type Item = BatchItem<T, N>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.idx >= self.array.len() {
            return None;
        }
        let len = (self.array.len() - self.idx).min(N);
        let range = self.idx..self.idx + len;

        assert_eq!(N % 8, 0, "batch size must be a multiple of 8");
        let mut valid = [0u8; std::mem::size_of::<usize>()];
        let bytes = (len + 7) / 8;
        valid[..bytes].copy_from_slice(unsafe {
            std::slice::from_raw_parts(
                (self.array.valid.as_raw_ptr() as *const u8).add(self.idx / 8),
                bytes,
            )
        });
        let valid = usize::from_le_bytes(valid);

        let data: [T; N] = if len == N {
            self.array.data[range].try_into().unwrap()
        } else {
            let mut data = [T::ZERO; N];
            data[..len].copy_from_slice(&self.array.data[range]);
            data
        };

        self.idx += N;
        Some(BatchItem { valid, data, len })
    }
}

impl<T: NativeType, const N: usize> FromIterator<BatchItem<T, N>> for PrimitiveArray<T> {
    fn from_iter<I: IntoIterator<Item = BatchItem<T, N>>>(iter: I) -> Self {
        let iter = iter.into_iter();
        let mut builder = PrimitiveArrayBuilder::new(iter.size_hint().0 * N);
        for e in iter {
            builder
                .valid
                .extend_from_bitslice(&BitSlice::<Lsb0, usize>::from_element(&e.valid)[..e.len]);
            builder.data.extend_from_slice(&e.data[..e.len]);
        }
        builder.finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use num_traits::cast::FromPrimitive;

    #[test]
    fn batch_iter() {
        let a = (0..12)
            .map(|i| if i % 2 == 0 { Some(i) } else { None })
            .collect::<PrimitiveArray<u32>>();
        let mut iter = a.batch_iter::<8>();
        assert_eq!(
            iter.next(),
            Some(BatchItem {
                valid: 0b_0101_0101,
                data: [0, 0, 2, 0, 4, 0, 6, 0],
                len: 8
            })
        );
        assert_eq!(
            iter.next(),
            Some(BatchItem {
                valid: 0b_0000_0101,
                data: [8, 0, 10, 0, 0, 0, 0, 0],
                len: 4
            })
        );
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn batch_iter_collect() {
        let a = (0..12).collect::<PrimitiveArray<u32>>();
        let a1 = a.batch_iter::<8>().collect::<PrimitiveArray<u32>>();
        assert_eq!(a1, a);
    }

    fn test_builder<T: FromPrimitive + NativeType>() {
        let iter = (0..1000).map(|x| if x % 2 == 0 { None } else { T::from_usize(x) });
        let array = iter.clone().collect::<PrimitiveArray<T>>();
        assert_eq!(
            array.iter().map(|x| x.cloned()).collect::<Vec<_>>(),
            iter.collect::<Vec<_>>()
        );
    }

    #[test]
    fn test_builder_i16() {
        test_builder::<i16>();
    }

    #[test]
    fn test_builder_i32() {
        test_builder::<i32>();
    }

    #[test]
    fn test_builder_i64() {
        test_builder::<i64>();
    }

    #[test]
    fn test_builder_f32() {
        test_builder::<f32>();
    }

    #[test]
    fn test_builder_f64() {
        test_builder::<f64>();
    }
}
