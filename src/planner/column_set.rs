use std::cmp::Ordering;
use std::collections::BTreeSet;
use std::str::FromStr;

use itertools::Itertools;
use parse_display::Display;

use crate::catalog::{ColumnRefId, ParseColumnIdError};

/// A set of columns.
///
/// This is a special value for column pruning.
/// The inner vector is always unique and sorted.
#[derive(Debug, Display, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[display("{0:?}")]
pub struct ColumnSet(Vec<ColumnRefId>);

impl ColumnSet {
    pub fn one(column: ColumnRefId) -> Self {
        ColumnSet(vec![column])
    }

    pub fn union(&self, other: &Self) -> Self {
        // merge two sorted vec
        use itertools::EitherOrBoth::*;
        let res = (self.0.iter())
            .merge_join_by(other.0.iter(), Ord::cmp)
            .map(|e| match e {
                Both(a, _) | Left(a) | Right(a) => a.clone(),
            })
            .collect();
        ColumnSet(res)
    }

    pub fn iter(&self) -> impl Iterator<Item = &ColumnRefId> {
        self.0.iter()
    }

    pub fn into_iter(self) -> impl Iterator<Item = ColumnRefId> {
        self.0.into_iter()
    }

    pub fn is_subset(&self, other: &Self) -> bool {
        let mut i = 0;
        let mut j = 0;
        // note: the following code is generated by Github Copilot
        while i < self.0.len() && j < other.0.len() {
            match self.0[i].cmp(&other.0[j]) {
                Ordering::Less => return false,
                Ordering::Equal => {
                    i += 1;
                    j += 1;
                }
                Ordering::Greater => j += 1,
            }
        }
        i == self.0.len()
    }

    pub fn is_disjoint(&self, other: &Self) -> bool {
        // note: the following code is generated by Github Copilot
        let mut i = 0;
        let mut j = 0;
        while i < self.0.len() && j < other.0.len() {
            match self.0[i].cmp(&other.0[j]) {
                Ordering::Less => i += 1,
                Ordering::Equal => return false,
                Ordering::Greater => j += 1,
            }
        }
        true
    }

    pub fn len(&self) -> usize {
        self.0.len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
}

impl FromIterator<ColumnRefId> for ColumnSet {
    fn from_iter<T: IntoIterator<Item = ColumnRefId>>(iter: T) -> Self {
        Self(
            iter.into_iter()
                .collect::<BTreeSet<_>>()
                .into_iter()
                .collect(),
        )
    }
}

#[derive(thiserror::Error, Debug, Clone)]
#[error("parse column set error: {}")]
pub enum ParseColumnSetError {
    #[error("no '[' or ']'")]
    NoBracket,
    #[error("{0}")]
    Column(#[from] ParseColumnIdError),
}

impl FromStr for ColumnSet {
    type Err = ParseColumnSetError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let s = s.strip_prefix('[').ok_or(Self::Err::NoBracket)?;
        let s = s.strip_suffix(']').ok_or(Self::Err::NoBracket)?;
        let mut cols = s
            .split(',')
            .map(|s| s.parse().map_err(Self::Err::Column))
            .collect::<Result<Vec<ColumnRefId>, _>>()?;
        cols.sort();
        Ok(Self(cols))
    }
}
