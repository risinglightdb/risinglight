use crate::binder::*;
use crate::catalog::ColumnRefId;
use crate::logical_planner::*;
use crate::optimizer::PlanRewriter;

/// Resolves column references into physical indices into the `DataChunk`.
///
/// This will rewrite all `ColumnRef` expressions to `InputRef`.
#[derive(Default)]
pub struct InputRefResolver {
    /// The output columns of the last visited plan.
    ///
    /// For those plans that don't change columns (e.g. Order, Filter), this variable should
    /// not be touched. For other plans that change columns (e.g. SeqScan, Join, Projection,
    /// Aggregate), this variable should be set before the function returns.
    bindings: Vec<Option<ColumnRefId>>,
}

impl PlanRewriter for InputRefResolver {
    fn rewrite_join(&mut self, plan: LogicalJoin) -> LogicalPlan {
        use BoundJoinConstraint::*;
        use BoundJoinOperator::*;

        let relation_plan = self.rewrite_plan(*plan.relation_plan);
        // TODO: Make the order of bindings consistent with the output order in executor
        let join_table_plans = plan
            .join_table_plans
            .into_iter()
            .map(|plan| {
                let mut resolver = Self::default();
                let table_plan = resolver.rewrite_plan(*plan.table_plan);
                self.bindings.append(&mut resolver.bindings);

                LogicalJoinTable {
                    table_plan: Box::new(table_plan),
                    join_op: match plan.join_op {
                        Inner(On(expr)) => Inner(On(self.rewrite_expr(expr))),
                    },
                }
            })
            .collect();

        LogicalPlan::Join(LogicalJoin {
            relation_plan: Box::new(relation_plan),
            // TODO: implement `rewrite_join` when `plan.join_table_plans` is not empty
            join_table_plans,
        })
    }

    fn rewrite_seqscan(&mut self, plan: LogicalSeqScan) -> LogicalPlan {
        self.bindings = plan
            .column_ids
            .iter()
            .map(|col_id| Some(ColumnRefId::from_table(plan.table_ref_id, *col_id)))
            .collect();
        LogicalPlan::SeqScan(plan)
    }

    fn rewrite_projection(&mut self, plan: LogicalProjection) -> LogicalPlan {
        let child = self.rewrite_plan(*plan.child);
        let mut bindings = vec![];
        let project_expressions = plan
            .project_expressions
            .into_iter()
            .map(|expr| {
                bindings.push(match &expr.kind {
                    BoundExprKind::ColumnRef(col) => Some(col.column_ref_id),
                    _ => None,
                });
                self.rewrite_expr(expr)
            })
            .collect();
        self.bindings = bindings;
        LogicalPlan::Projection(LogicalProjection {
            project_expressions,
            child: Box::new(child),
        })
    }

    fn rewrite_aggregate(&mut self, plan: LogicalAggregate) -> LogicalPlan {
        let child = self.rewrite_plan(*plan.child);

        let agg_calls = plan
            .agg_calls
            .into_iter()
            .map(|agg| BoundAggCall {
                kind: agg.kind,
                args: agg
                    .args
                    .into_iter()
                    .map(|expr| self.rewrite_expr(expr))
                    .collect(),
                return_type: agg.return_type,
            })
            .collect();

        let group_keys = plan
            .group_keys
            .into_iter()
            .map(|expr| {
                match &expr.kind {
                    BoundExprKind::ColumnRef(col) => self.bindings.push(Some(col.column_ref_id)),
                    _ => panic!("{:?} cannot be a group key", expr.kind),
                }
                self.rewrite_expr(expr)
            })
            .collect();

        LogicalPlan::Aggregate(LogicalAggregate {
            agg_calls,
            group_keys,
            child: Box::new(child),
        })
    }

    /// Transform expr referring to input chunk into `BoundInputRef`
    fn rewrite_expr(&mut self, expr: BoundExpr) -> BoundExpr {
        use BoundExprKind::*;
        let new_kind = match expr.kind {
            ColumnRef(column_ref) => InputRef(BoundInputRef {
                index: self
                    .bindings
                    .iter()
                    .position(|col| *col == Some(column_ref.column_ref_id))
                    .expect("column reference not found"),
            }),
            AggCall(agg) => AggCall(BoundAggCall {
                kind: agg.kind,
                args: agg
                    .args
                    .into_iter()
                    .map(|expr| self.rewrite_expr(expr))
                    .collect(),
                return_type: agg.return_type,
            }),
            // rewrite sub-expressions
            BinaryOp(binary_op) => BinaryOp(BoundBinaryOp {
                left_expr: Box::new(self.rewrite_expr(*binary_op.left_expr)),
                op: binary_op.op,
                right_expr: Box::new(self.rewrite_expr(*binary_op.right_expr)),
            }),
            UnaryOp(unary_op) => UnaryOp(BoundUnaryOp {
                op: unary_op.op,
                expr: Box::new(self.rewrite_expr(*unary_op.expr)),
            }),
            TypeCast(cast) => TypeCast(BoundTypeCast {
                expr: Box::new(self.rewrite_expr(*cast.expr)),
                ty: cast.ty,
            }),
            kind => kind,
        };
        BoundExpr {
            kind: new_kind,
            return_type: expr.return_type,
        }
    }
}
